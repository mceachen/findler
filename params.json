{"name":"Findler","body":"[![Build Status](https://secure.travis-ci.org/mceachen/findler.png?branch=master)](http://travis-ci.org/mceachen/findler)\r\n\r\nFindler is a Ruby library for iterating over a filtered set of files from a given\r\npath, written to be suitable with concurrent workers and very large\r\nfilesystem hierarchies.\r\n\r\n## Usage\r\n\r\n```ruby\r\nf = Findler.new \"/Users/mrm\"\r\nf.add_extensions \".jpg\", \".jpeg\"\r\niterator = f.iterator\r\niterator.next_file\r\n# => \"/Users/mrm/Photos/img_1000.jpg\"\r\n```\r\n\r\n## Cross-process continuations\r\n\r\nThis should smell an awful lot like [hike](https://github.com/sstephenson/hike),\r\nexcept for that last bit.\r\n\r\n```Findler::Iterator``` instances can be \"paused\" and \"resumed\" with ```Marshal```.\r\nThe entire state of the iteration for the filesystem is returned, which can then\r\nbe pushed onto any durable storage, like ActiveRecord or Redis, or just a local file:\r\n\r\n```ruby\r\nFile.open('iterator.state', 'w') { |f| Marshal.dump(iterator, f) }\r\n```\r\n\r\nTo resume iteration:\r\n\r\n```ruby\r\nMarshal.load(IO.open('iterator.state'))\r\niterator.next_file\r\n# => \"/Users/mrm/Photos/img_1001.jpg\"\r\n```\r\n\r\nTo re-check a directory hierarchy for files that you haven't visited yet:\r\n\r\n```ruby\r\niterator.rescan!\r\niterator.next_file\r\n# => \"/Users/mrm/Photos/img_1002.jpg\"\r\n```\r\n\r\nExternal synchronization between the serialized state of the\r\niterator and the other processes will have to be done by you, of course.\r\nThe ```load```, ```next_file``` , and ```dump``` should be done while holding\r\nan iteration mutex of some sort.\r\n\r\n## Filtering and ordering\r\n\r\nFilters provide custom exclusion and ordering criteria, so you don't\r\nhave to do that logic in the code that consumes from your iterator.\r\n\r\nFilters can't be procs or lambdas because those aren't safely serializable.\r\n\r\nWhat you provide to ```add_filter``` is a symbolized name of a class method\r\non ```Findler::Filters```:\r\n\r\n```ruby\r\nf = Findler.new(\".\")\r\nf.add_filter :order_by_name\r\n```\r\n\r\nNote that the last filter added will be last to order the children, so it will be the\r\n\"primary\" sort criterion. Note also that the ordering is only done in\r\nthe context of a given directory.\r\n\r\n### Implementing your own filter\r\n\r\nFilter methods receive an array of ```Pathname``` instances. Those pathnames will:\r\n\r\n1. have the same parent\r\n2. will not have been enumerated by ```next_file()``` already\r\n3. will satisfy the settings given to the parent Findler instance, like ```include_hidden```\r\n   and added patterns.\r\n\r\nNote that the last filter added will be last to order the children, so it will be the\r\n\"primary\" sort criterion.\r\n\r\nThe returned values from the class method will be the final set of elements (both files\r\nand directories) that Findler will return from ```next_file()```.\r\n\r\n### Example\r\n\r\nTo find files that have valid EXIF headers, using the *most* excellent\r\n[exiftoolr](https://github.com/mceachen/exiftoolr) gem, you'd do this:\r\n\r\n```ruby\r\nrequire 'findler'\r\nrequire 'exiftoolr'\r\n\r\n# Monkey-patch Filters to add our custom filter:\r\nclass Findler::Filters\r\n  def self.exif_only(children)\r\n    child_files = children.select{|ea|ea.file?}\r\n    child_dirs = children.select{|ea|ea.directory?}\r\n    e = Exiftoolr.new(child_files)\r\n    e.files_with_results + child_dirs\r\n  end\r\nend\r\n\r\nf = Findler.new \"/Users/mrm\"\r\nf.add_extensions \".jpg\", \".jpeg\", \".cr2\", \".nef\"\r\nf.case_insensitive!\r\nf.add_filter(:exif_only)\r\n```\r\n\r\n### Filter implementation notes\r\n\r\n* The array of ```Pathname``` instances can be assumed to be absolute.\r\n* Only child files that satisfy the ```extension``` and ```pattern``` filters will be seen by the filter class method.\r\n* If a directory doesn't have any relevant files, the filter method will be called multiple times for a given call to ```next_file()```.\r\n* if you want to be notified when new directories are walked into, and you want to do a bulk operation within that directory,\r\n  this gives you that hookâ€“-just remember to return the children array at the end of your block.\r\n\r\n### Why can't ```filter_with``` be a proc?\r\n\r\nBecause procs and lambdas aren't Marshal-able, and I didn't want to use something scary like ruby2ruby and eval.\r\n\r\n## Changelog\r\n\r\n* 0.0.4 Added custom filters for ```next_file()``` and singular aliases for ```add_extension``` and ```add_pattern```\r\n* 0.0.3 Fixed gemfile packaging\r\n* 0.0.2 Added scalable Bloom filter so ```Iterator#rescan``` is possible\r\n* 0.0.1 First `find`","tagline":"A Ruby library for filesystem iteration with persistable state","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}